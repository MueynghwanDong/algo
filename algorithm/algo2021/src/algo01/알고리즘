비트마스크
AND(&) 연산
대응하는 두 비트가 모두 1일 때 1을 반환
OR(|) 연산
대응 하는 두 비트가 모두 1 또는 하나라도 1일 때 1을 반환
XOR(^) 연산
대응하는 두 비트가 서로 다르면 1 반환
NOT(~) 연산
비트의 값을 반전해 반환
시프트 연산(>>,<<)
왼쪽 or 오른쪽으로 비트를 옮김 (A/2^B , A*2^B 를 의미)
00001010 << 2 = 101000
00001010 >> 2 = 000010

플로이드-와샬
- 이 알고리즘은 다이나믹 프로그래밍 기술에 의거한다
- 거쳐가는 정점을 기준으로 최단거리를 구하는 것이 핵심!!
- x에서 y로 가는 최소 비용과 x에서 1로가는 비용 + 1에서 y로 가는 비용을 비교

// k는 거쳐가는 노드
for (int k = 1; k <= n; k++) {
	// i 는 출발 노드 j는 도착 노드 
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (arr[i][k] + arr[k][j] < arr[i][j])
				arr[i][j] = arr[i][k] + arr[k][j];
		}
	}
}