
/**
 * 비선형 자료 구조의 그래프문제에서 모든 정점을 빠짐없이 순회하는 방법 
 * DFS : 깊이 우선 탐색 -> Stack 
 * BFS : 너비 우선 탐색 -> Queue 
 * input 1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7 
 * output DFS로 순회하면서 정점을 출력 
 * 1번 정점부터 시작 1 2 4 6 5 7 3 or 1 3 7 6 5 3 4
 */
public class Z16_DFS {

	public static void main(String[] args) {

		int[][] G = { // 정점에 연결된 정보를 저장
				{}, // 0번 정점에 인접한 정점
				{ 2, 3, }, // 1번 정점에 인접한 정점
				{ 1, 4, 5 }, // 2번 정점에 인접한 정점
				{ 1, 7 }, // 3번 정점에 인접한 정점
				{ 2, 6 }, // 4번 정점에 인접한 정점
				{ 2, 6 }, // 5번 정점에 인접한 정점
				{ 4, 5, 7 }, // 6번 정점에 인접한 정점
				{ 3, 6 }, // 7번 정점에 인접한 정점
		};

		int[] stack = new int[20]; // 부족하지 않도록 스택 크기 지정
		int top = -1; // 스택에 index를 관리할 변수
		boolean[] visited = new boolean[8]; // 각 정점의 방문여부를 체크할 변수 , 0번 정점 안씀..

		// 시작 정점을 지정, 시작 정점 방문, 스택에 시작정점 넣고 반복 시작
		int v = 1; // 시작 정점 지정. 1 A를 의미
		visited[v] = true;
		System.out.print(v+" "); // 방문하면 정점 출력
		stack[++top]= v;
		// 반복 시작 : 스택이 비워질 때 까지 반복, 스택에서 정점을 꺼내, 인접한 방문하지 않은 정점 방문 작업 반복
		while(top> -1) {
			int w = -1;// 다음 정점을 저장할 변수, 플래그 변수 역할도 겸함. 
			for (int i = 0; i < G[v].length; i++) { // v 정점에 인접한 정점만큼 반복
				if(!visited[G[v][i]]) {// 방문하지않은 정점이면, 방문하기
					w = G[v][i]; // 다음 갈 정점을 w 에 저장
					stack[++top] = w;
					visited[w] = true; // 방문 여부 체크
					System.out.print(w + " "); // 방문 하면 정점 출력
					v = w;
					break; // 인접한 정점중 방문하지 않은 정점을 찾으면  go go, for문 종료
				}
			}	
			if(w==-1) { // 인접한 정점 중, 방문하지 않은 정점이 없는 것 (막다른 골목)
				v= stack[top--]; // 스택에서 마지막 갈림김을 꺼냄
			}
			
		}
	} // end of main
	
} // end of class
